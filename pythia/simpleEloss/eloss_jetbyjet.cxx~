//CERN Summer Students Programme 2019
//Author: Gabriel Garcia

#include "fastjet/Selector.hh" //.......... Background Sutraction event by event
#include "fastjet/tools/JetMedianBackgroundEstimator.hh"//.......... Background Sutraction event by event
#include "fastjet/PseudoJet.hh"
#include "fastjet/ClusterSequence.hh"
#include "fastjet/ClusterSequenceArea.hh"
#include "fastjet/ClusterSequenceAreaBase.hh"
#include "fastjet/tools/Subtractor.hh"
#include "fastjet/contrib/ConstituentSubtractor.hh"
#include "fastjet/contrib/Nsubjettiness.hh"
#include "fastjet/contrib/SoftDrop.hh"
#include "fastjet/contrib/ModifiedMassDropTagger.hh"
#include "fastjet/contrib/Recluster.hh"
#include <algorithm>
#include <iostream>
#include <vector>
#include <math.h>
#include <iomanip>
#include <string>
#include <cstring>
#include <fstream>
#include <stdlib.h>
#include <sstream>
#include "Pythia8/Pythia.h"
#include "TTree.h"
#include "THnSparse.h"
#include "TProfile.h"
#include "TH1F.h"
#include "TH2F.h"
#include "TF1.h"
#include "TFile.h"
#include "TClonesArray.h"
#include "TFile.h"
#include "TList.h"
#include "TVector3.h"
#include "TMath.h"
#include "THnSparse.h"
#include "TNtuple.h"
#include "TString.h"
#include "TRandom3.h"
#include "TH1D.h"
#include "fastjet/PseudoJet.hh"
#include "fastjet/ClusterSequence.hh"
#include "fastjet/ClusterSequenceArea.hh"  
#include <ctime>
#include <iostream> // needed for io
#include <cstdio>   // needed for io
#include <valarray>

#define nEvents 20000

#define nThermalParticles 4000

using namespace Pythia8;

double Calculate_pX( double pT, double eta, double phi)
{
	return(pT*TMath::Cos(phi));
}

double Calculate_pY( double pT, double eta, double phi)
{
	return(pT*TMath::Sin(phi));
}

double Calculate_pZ( double pT, double eta, double phi)
{
	return( pT*TMath::SinH(eta) );
}

double Calculate_E( double pT, double eta, double phi)
{
	double pZ = Calculate_pZ(pT,eta, phi);

	return( TMath::Sqrt(pT*pT + pZ*pZ) );
}

//__________________________________________________________________________

bool EtaCut(fastjet::PseudoJet fjJet, double etaMin, double etaMax) {
   if(fjJet.eta() > etaMax || fjJet.eta() < etaMin){
      return false;
   }else{
      return true;
   }
}
//_________________________________________________________________________ 
Double_t RelativePhi(Double_t mphi,Double_t vphi){
   //Get relative azimuthal angle of two particles -pi to pi
   if      (vphi < -TMath::Pi()) vphi += TMath::TwoPi();
   else if (vphi > TMath::Pi())  vphi -= TMath::TwoPi();

   if      (mphi < -TMath::Pi()) mphi += TMath::TwoPi();
   else if (mphi > TMath::Pi())  mphi -= TMath::TwoPi();

   Double_t dphi = mphi - vphi;
   if      (dphi < -TMath::Pi()) dphi += TMath::TwoPi();
   else if (dphi > TMath::Pi())  dphi -= TMath::TwoPi();

   return dphi;//dphi in [-Pi, Pi]
}
//__________________________________________________________________________



//Lund_____________________________________________________________________________________

THnSparse *fHLundIterative;
THnSparse *fHLundIterativeOriginal;


//ITERATIVE DECLUSTERING____________________________________________________

void IterativeDeclustering(fastjet::PseudoJet jet, Double_t w, TH1D *h, TH1D *hg)
{
   	double flagSubjet=0;
   	double tform=0;
   	double erad=0;
   	double nall=0;
   	double rad=0;
	double form=0;

	//_________________________________________________________________________________________

   	// Reclustering settings, using generic kt algorithm with p=1/2, which orders in vacuum formation time

	//fastjet::JetAlgorithm jet_algo(fastjet::cambridge_algorithm);
	//double jet_radius_ca = 1.0;
   	//fastjet::JetDefinition jet_def(jet_algo, jet_radius_ca,static_cast<fastjet::RecombinationScheme>(0), fastjet::Best);

   	double jet_radius_ca = 1.0;
   	fastjet::JetDefinition jet_def(fastjet::genkt_algorithm,jet_radius_ca,0,static_cast<fastjet::RecombinationScheme>(0), fastjet::Best);

   	// Reclustering jet constituents with new algorithm
      	try
	{
      		std::vector<fastjet::PseudoJet> particles = jet.constituents();
      		fastjet::ClusterSequence cs_gen(particles, jet_def);
      		std::vector<fastjet::PseudoJet> output_jets = cs_gen.inclusive_jets(0);
      		output_jets = sorted_by_pt(output_jets);
        	 
      		// input jet but reclustered with ca
      		fastjet::PseudoJet jj = output_jets[0];
        	 
      		// Auxiliar variables
      		fastjet::PseudoJet j1;  // subjet 1 (largest pt)
      		fastjet::PseudoJet j2;  // subjet 2 (smaller pt)

		double aux = 1;
		double auxg = 1;

      		// Unclustering jet
      		while(jj.has_parents(j1,j2))
		{      
         
        		if(j1.perp() < j2.perp()) std::swap(j1,j2);
        		nall=nall+1;
       	 		
     	 		
        		// Calculate deltaR and Zg between j1 and j2
        		double delta_R = j1.delta_R(j2);

			if(aux)h->Fill(delta_R);
			aux = 0;

			if( j2.perp()/(j2.perp()+j1.perp()) > 0.1 && auxg )
			{
				hg->Fill(delta_R);
				auxg = 0;
			}

			double xkt=j2.perp()*sin(delta_R);
			double lnpt_rel = log(xkt);
			double y = log(1./delta_R);
			 
			form=2*0.197*j2.e()/(xkt*xkt); //in fermis
			rad=j2.e();
			 
			if(xkt>1) tform=tform+form;
			if(xkt>1) erad=erad+rad;
        		double lundEntriesOriginal[6] = {y,lnpt_rel,output_jets[0].perp(),form,rad,nall};
        		fHLundIterativeOriginal->Fill(lundEntriesOriginal);
        		 
        		//continue unclustering
        		jj=j1;
      		}	
		double lundEntries[3] = {output_jets[0].perp(),tform,erad};
		fHLundIterative->Fill(lundEntries,w);
     	 
       	  
	} catch (fastjet::Error) { /*return -1;*/ }
}

//__________________________________________________________________________


int main(int , char**)
{
	const Int_t dimSpec   = 3;
	const Int_t nBinsSpec[3]     = {200,100,200};
	const Double_t lowBinSpec[3] = {0,0,0};
	const Double_t hiBinSpec[3]  = {14000,10,400};
	fHLundIterative = new 
	THnSparseF("fHLundIterative","LundIterativePlot[jetpt,tform,erad]",dimSpec,nBinsSpec,lowBinSpec,hiBinSpec);

	const Int_t dimSpec2   = 8;
	const Int_t nBinsSpec2[8]     = {50,100,200,10,100,100,100,20};
	const Double_t lowBinSpec2[8] = {0,-10,0,0,0,0,0,0};
	const Double_t hiBinSpec2[8]  = {5,10,14000,0.5,20,20,100,20};
	fHLundIterativeOriginal = new THnSparseF("fHLundIterativeOriginal","LundIterativeOriginal[jetpt,tform,erad]"
						,dimSpec2,nBinsSpec2,lowBinSpec2,hiBinSpec2);



//__________________________________________________________________________
//ANALYSIS SETTINGS

	double jetParameterR   = 0.4; //jet R
	double trackEtaCut     = 1;
	double trackLowPtCut   = 0.15; //GeV
//__________________________________________________________________________
//PYTHIA SETTINGS

	TString name;

	int mecorr=1;

	Float_t ptHatMin=80;
	Float_t ptHatMax=100;

	// Generator. Process selection. LHC initialization. Histogram.
	Pythia pythia;
	pythia.readString("Beams:idA = 2212"); //beam 1 proton
	pythia.readString("Beams:idB = 2212"); //beam 2 proton
	pythia.readString("Beams:eCM = 13000.");
	pythia.readString("Tune:pp = 5");  //tune 1-13    5=defaulr TUNE4C,  6=Tune 4Cx, 7=ATLAS MB Tune A2-CTEQ6L1

	pythia.readString("Random:setSeed = on");
	pythia.readString("Random:seed = 0");

  
	pythia.readString("HardQCD:all = on");
	if(ptHatMin<0 || ptHatMax <0){     
	pythia.readString("PhaseSpace:pTHatMin = 0."); // <<<<<<<<<<<<<<<<<<<<<<<
	}else{
	name = Form("PhaseSpace:pTHatMin = %f", (Float_t) ptHatMin);
	pythia.readString(name.Data()); 
	name = Form("PhaseSpace:pTHatMax = %f", (Float_t) ptHatMax);
	pythia.readString(name.Data()); 
	}

	//if(nEvents==0){
	//pythia.readString("PartonLevel:MPI = off");
	//pythia.readString("PartonLevel:ISR = off");
	//}
  
   
	pythia.readString("310:mayDecay  = off"); //K0s
	pythia.readString("3122:mayDecay = off"); //labda0
	pythia.readString("3112:mayDecay = off"); //sigma-
	pythia.readString("3212:mayDecay = off"); //sigma0
	pythia.readString("3222:mayDecay = off"); //sigma+
	pythia.readString("3312:mayDecay = off"); //xi-
	pythia.readString("3322:mayDecay = off"); //xi+
	pythia.readString("3334:mayDecay = off"); //omega-

	//ME corrections
	//use of matrix corrections where available
	if(mecorr==0){ 
	pythia.readString("TimeShower:MECorrections=off");
	}
	pythia.init();
 
//_________________________________________________________________________________________________
//FASTJET  SETTINGS

	double etamin_Sig = - trackEtaCut + jetParameterR; //signal jet eta range
	double etamax_Sig = - etamin_Sig;


	fastjet::Strategy strategy = fastjet::Best;
	fastjet::RecombinationScheme recombScheme = fastjet::E_scheme;

	fastjet::JetDefinition *jetDefAKT_Sig = NULL;

	jetDefAKT_Sig = new fastjet::JetDefinition(fastjet::antikt_algorithm, jetParameterR, recombScheme, strategy);
 
        /*
        // This code is not used
	fastjet::GhostedAreaSpec ghostareaspec(trackEtaCut, 1, 0.05); //ghost 
	//max rap, repeat, ghostarea default 0.01
	fastjet::AreaType areaType = fastjet::active_area_explicit_ghosts;
	fastjet::AreaDefinition *areaDef = new fastjet::AreaDefinition(areaType, ghostareaspec);
        */
	// Fastjet input
	std::vector<fastjet::PseudoJet> fjInputs1;

	std::vector<fastjet::PseudoJet> fjInputs2;
//___________________________________________________ 
//HISTOGRAMS

	//After Thermal Particles: "A-Histograms"
	TH1D *hJetPt_A = new TH1D("hJetPt_A","hJetPt_A;p_{T} (GeV/c)", 200,0.0,400.0);
	hJetPt_A->Sumw2();

	TH1D *hJetEta_A = new TH1D("hJetEta_A","hJetEta_A;#eta", 40, -1.0, 1.0);
	hJetEta_A->Sumw2();

	TH1D* hJetArea_A = new TH1D("hJetArea_A", "hJetArea_A;A", 400, 0.0, 4.0);
	hJetArea_A->Sumw2();

	TH1D *hJetMatchFrac = new TH1D("hJetMatchFrac","hJetMatchFrac;match frac", 40, 0.0, 1.0);
	hJetMatchFrac->Sumw2();

	TH1D *hDeltaPt = new TH1D("hDeltaPt","hDeltaPt;#deltap_{T} (GeV/c)", 250,-50,50);
	hDeltaPt->Sumw2();

	TH1D *hJet_Rconst_A = new TH1D("hJet_Rconst_A", "hJet_Rconst_A;R_{jet,part};dN/dR", 100, 0.0, 1.0);
	hJet_Rconst_A->Sumw2();

	TH1D *hJet_RhoR_A = new TH1D("hJet_RhoR_A", "hJet_RhoR_A;R_{jet,part};#rho(R)", 100, 0.0, 1.0);
	hJet_RhoR_A->Sumw2();

	TH1D *hJet_Rghost_A = new TH1D("hJet_Rghost_A", "hJet_Rghost_A;R_{jet,ghost}", 100, 0.0, 1.0);
	hJet_Rghost_A->Sumw2();

	TH1D *hJet_deltaR_A = new TH1D("hJet_deltaR_A", "hJet_deltaR_A;#DeltaR", 100, 0.0, 1.0);
	hJet_deltaR_A->Sumw2();

	TH1D *hJet_deltaRg_A = new TH1D("hJet_deltaRg_A", "hJet_deltaRg_A;#DeltaR_{g}", 100, 0.0, 1.0);
	hJet_deltaRg_A->Sumw2();
        
        // without bg subtraction
	//TH1D *hJet_deltaRg_A_nobgsub = new TH1D("hJet_deltaRg_A_nobgsub", "hJet_deltaRg_A without bg subtraction", 100, 0.0, 1.0);
	//hJet_deltaRg_A_nobgsub->Sumw2();

	//Before Thermal Particles "B-Histograms"
	TH1D *hJetPt_B = new TH1D("hJetPt_B","hJetPt_B;p_{T} (GeV/c)", 200,0.0,400.0);
	hJetPt_B->Sumw2();

	TH1D *hJetEta_B = new TH1D("hJetEta_B","hJetEta_B;#eta", 40, -1.0, 1.0);
	hJetEta_B->Sumw2();

	TH1D* hJetArea_B = new TH1D("hJetArea_B", "hJetArea_B;A", 400, 0.0, 4.0);
	hJetArea_B->Sumw2();

	TH1D *hJet_Rconst_B = new TH1D("hJet_Rconst_B", "hJet_Rconst_B;R_{jet,part};dN/dR", 100, 0.0, 1.0);
	hJet_Rconst_B->Sumw2();

	TH1D *hJet_RhoR_B = new TH1D("hJet_RhoR_B", "hJet_RhoR_B;R_{jet,part};#rho(R)", 100, 0.0, 1.0);
	hJet_RhoR_B->Sumw2();

	TH1D *hJet_deltaR_B = new TH1D("hJet_deltaR_B", "hJet_deltaR_B;#DeltaR", 100, 0.0, 1.0);
	hJet_deltaR_B->Sumw2();

	TH1D *hJet_deltaRg_B = new TH1D("hJet_deltaRg_B", "hJet_deltaRg_B;#DeltaR_{g}", 100, 0.0, 1.0);
	hJet_deltaRg_B->Sumw2();

	//PARTICLE DISTRIBUITIONS

	TH1D *h_pT = new TH1D("h_pT","",40000,0.0,400);
	TH1D *h_eta = new TH1D("h_eta","",200,-1.0,1.0);
	TH1D *h_phi = new TH1D("h_phi","",700,-3.5,3.5);

	TH1D *hP_pT = new TH1D("hP_pT","",40000,0.0,400);
	TH1D *hP_eta = new TH1D("hP_eta","",200,-1.0,1.0);
	TH1D *hP_phi = new TH1D("hP_phi","",700,-3.5,3.5);

	TH1D *hT_pT = new TH1D("hT_pT","",40000,0.0,400);
	TH1D *hT_eta = new TH1D("hT_eta","",200,-1.0,1.0);
	TH1D *hT_phi = new TH1D("hT_phi","",700,-3.5,3.5);

//___________________________________________________ 
//Thermal Particles Distribuitions (toy model)

	TF1* f_pT = new TF1("f_pT","x*exp(-x/0.3)", 0.0, 400.0);
	f_pT->SetNpx(40000);

	TF1* f_eta = new TF1("f_eta", "1", -1.0, 1.0);
	f_eta->SetNpx(200);

	TF1* f_phi = new TF1("f_phi", "1", (-1.0)*TMath::Pi(), TMath::Pi() );
	f_phi->SetNpx(700);
//___________________________________________________

//Begin event loop
        int n_matched = 0;
	for(int i = 0; i < nEvents; i++)
	{
		double fourvec[4];

		//1st Step: Pythia + FastJet -> Probe Jet := Hardest Jet generated by Pythia.
		if(!pythia.next()) continue;
		
		fjInputs1.resize(0);

		for(int j = 0; j < pythia.event.size(); j++)
		{
			if(pythia.event[j].isFinal())
			{
				//Apply cuts in the particles
				if(pythia.event[j].pT() < trackLowPtCut) continue;                 //pt cut
	     			if(TMath::Abs(pythia.event[j].eta()) > trackEtaCut) continue;      //eta cut

				//h_pT->Fill(pythia.event[j].pT());
				//h_eta->Fill(pythia.event[j].eta());
				//h_phi->Fill(pythia.event[j].phi());

				fourvec[0]=pythia.event[j].px();
             			fourvec[1]=pythia.event[j].py();
             			fourvec[2]=pythia.event[j].pz();
             			fourvec[3]=pythia.event[j].e();

				fastjet::PseudoJet PythiaParticle(fourvec);

				fjInputs1.push_back(PythiaParticle);
			}
		}

		//Jet Reconstruction:
		std::vector<fastjet::PseudoJet> PythiaJets;//Declaration of vector for Reconstructed Jets

		fastjet::GhostedAreaSpec ghost_spec(1, 1, 0.05);//Ghosts to calculate the Jet Area

		fastjet::AreaDefinition fAreaDef(fastjet::passive_area,ghost_spec);//Area Definition

		fastjet::ClusterSequenceArea clustSeq_Sig(fjInputs1, *jetDefAKT_Sig, fAreaDef);//Cluster Sequence

		PythiaJets = sorted_by_pt(clustSeq_Sig.inclusive_jets(1.));//Vector with the Reconstructed Jets in pT order
		//__

		if(PythiaJets.size()==0) continue;

		if(PythiaJets[0].pt()<80.0) continue;
		if(PythiaJets[0].pt()>100.0) continue;

		fastjet::PseudoJet ProbeJet = PythiaJets[0];//Hardest Pythia Jet
		
		//Fill "B-Histograms"
		
		hJetPt_B->Fill(ProbeJet.pt());
		hJetEta_B->Fill(ProbeJet.eta());
		
		hJetArea_B->Fill(ProbeJet.area());

		IterativeDeclustering(ProbeJet, 1, hJet_deltaR_B, hJet_deltaRg_B);//Fill the deltaR and groomed deltaR "B-Histograms"

		//_________________________________________________________________________________

		//2nd Step: Thermal Particles + Probe Particles + FastJet (again) + CONSTITUENTS SUBTRACTION -> New Jets
		fjInputs2.resize(0);

		//Thermal Particles loop
		for(int j = 0; j < nThermalParticles; j++)
		{
			double pT = f_pT->GetRandom();

			double eta = f_eta->GetRandom();

			double phi = f_phi->GetRandom();

			if(pT < trackLowPtCut) continue;//pt cut
			
			hT_pT->Fill(pT);
			hT_eta->Fill(eta);
			hT_phi->Fill(phi);

			h_pT->Fill(pT);
			h_eta->Fill(eta);			
			h_phi->Fill(phi);

			fourvec[0] = Calculate_pX( pT, eta, phi );
			fourvec[1] = Calculate_pY( pT, eta, phi );
			fourvec[2] = Calculate_pZ( pT, eta, phi );
			fourvec[3] = Calculate_E( pT, eta, phi );

			fastjet::PseudoJet ThermalParticle(fourvec);

			ThermalParticle.set_user_index(0);

	     		fjInputs2.push_back(ThermalParticle);
		}

		//Probe Particles loop

		std::vector<fastjet::PseudoJet> ProbeParticles = sorted_by_pt(ProbeJet.constituents());

		for(unsigned int j = 0; j < ProbeParticles.size(); j++)
		{	
			hP_pT->Fill(ProbeParticles[j].pt());
			hP_eta->Fill(ProbeParticles[j].eta());
			hP_phi->Fill(ProbeParticles[j].phi());

			h_pT->Fill(ProbeParticles[j].pt());
			h_eta->Fill(ProbeParticles[j].eta());
			h_phi->Fill(ProbeParticles[j].phi());
			
			ProbeParticles[j].set_user_index(1);

			fjInputs2.push_back( ProbeParticles[j] );

                        hJet_Rconst_B->Fill(ProbeJet.delta_R(ProbeParticles[j]));
                        hJet_RhoR_B->Fill(ProbeJet.delta_R(ProbeParticles[j]),ProbeParticles[j].pt());
		}


		//________________________
		
		//Jet Reconstruction:
		//fastjet::AreaType areaType = fastjet::active_area;

		std::vector<fastjet::PseudoJet> NewJets;//Declaration of vector for Reconstructed Jets

                // MvL: changes ghost area to 0.01
		fastjet::GhostedAreaSpec New_ghost_spec(1, 1, 0.005);//Ghosts to calculate the Jet Area

		fastjet::AreaDefinition New_fAreaDef(fastjet::active_area_explicit_ghosts,New_ghost_spec);//Area Definition
                // MvL: try without explicit ghosts; does not work; no bkg subtraction
		// fastjet::AreaDefinition New_fAreaDef(fastjet::passive_area,New_ghost_spec);//Area Definition

       		fastjet::ClusterSequenceArea New_clustSeq_Sig(fjInputs2, *jetDefAKT_Sig, New_fAreaDef);//Cluster Sequence

      		NewJets = New_clustSeq_Sig.inclusive_jets(1.);//Vector with the Reconstructed Jets

		//________________________

		//CONSTITUENTS SUBTRACTION JET BY JET:

		fastjet::JetMedianBackgroundEstimator bge;

		fastjet::Selector BGSelector = fastjet::SelectorAbsEtaMax(1.0);

		fastjet::JetDefinition jetDefBG(fastjet::kt_algorithm, jetParameterR, recombScheme, strategy);

		fastjet::AreaDefinition fAreaDefBG(fastjet::active_area_explicit_ghosts,New_ghost_spec);
                // MvL: try without explicit ghosts
		//fastjet::AreaDefinition fAreaDefBG(fastjet::passive_area,New_ghost_spec);

		fastjet::ClusterSequenceArea clustSeqBG(fjInputs2, jetDefBG, fAreaDefBG);

		std::vector <fastjet::PseudoJet> BGJets = clustSeqBG.inclusive_jets();

	        bge.set_selector(BGSelector);

	     	bge.set_jets(BGJets);
		
		fastjet::contrib::ConstituentSubtractor subtractor(&bge);

		subtractor.set_common_bge_for_rho_and_rhom(true);
		// for massless input particles it does not make any difference (rho_m is always zero)
	
                // MvL change to 2*R
		subtractor.set_max_standardDeltaR(2*jetParameterR);
		//subtractor.set_alpha(0.5);

		for(int j = 0; j < NewJets.size(); j++)
		{
			//SUBTRACTION HERE:

			const fastjet::PseudoJet &jet = NewJets[j];

			fastjet::PseudoJet subtracted_Jet = subtractor(jet);	

			NewJets[j] = subtracted_Jet;
		}
		//_________________________________________________________________________________

		//3rd Step: MATCHING := Find in NewJets the Jet with the constituents that satisfy the condition
		//#Sigma_{constituents with index=1} p_{T}_{constituent} >= 0.5*p_{T}_{ProbeJet} 

		int MATCH = -1;
                double MATCH_frac = 0.0;

          	for(int j = 0; j < NewJets.size(); j++)
		{
			fastjet::PseudoJet NJet = NewJets.at(j);

			if(!EtaCut(NJet, etamin_Sig, etamax_Sig)) continue;
			if(NJet.pt()   < 0.5*ProbeJet.pt()) continue;
         
			double MATCH_pT = 0.0;

			std::vector<fastjet::PseudoJet> constituents = sorted_by_pt(NJet.constituents());

			for(int k = 0; k < constituents.size(); k++)
				if( constituents.at(k).user_index() == 1 )
					MATCH_pT += constituents.at(k).pt();

			if( MATCH_pT >= 0.5*ProbeJet.pt() )
			{
				MATCH = j;	
                                MATCH_frac = MATCH_pT/ProbeJet.pt();
				break;
			}
		}

                // MvL: change to MATCH >= 0
		if(MATCH >= 0)
		{
                        n_matched++;
			fastjet::PseudoJet MatchedJet = NewJets.at(MATCH);

			//Fill "A-Histograms"

			hJetPt_A->Fill(MatchedJet.pt());
			hJetEta_A->Fill(MatchedJet.eta());
			hJetMatchFrac->Fill(MATCH_frac);
                        hDeltaPt->Fill(MatchedJet.pt() - ProbeJet.pt());
		
			//hJetArea_A->Fill(MatchedJet.area());

                        for (int ic = 0; ic < MatchedJet.constituents().size(); ic++) {
                           if (MatchedJet.constituents()[ic].pt() < 0.0001) {

                             hJet_Rghost_A->Fill(MatchedJet.delta_R(MatchedJet.constituents()[ic]));
                             //cout << "suspected ghost: " << ic << " pt " << std::setprecision(6) << MatchedJet.constituents()[ic].pt()  << endl;
                           }
                           else {
                             hJet_Rconst_A->Fill(MatchedJet.delta_R(MatchedJet.constituents()[ic]));
                             hJet_RhoR_A->Fill(MatchedJet.delta_R(MatchedJet.constituents()[ic]),MatchedJet.constituents()[ic].pt());
                           }
                        }
			IterativeDeclustering(MatchedJet, 1, hJet_deltaR_A, hJet_deltaRg_A);//Fill the deltaR and groomed deltaR "A-Histograms"
			//IterativeDeclustering(MatchedJet, 1, hJet_deltaR_A_nobgsub, hJet_deltaRg_A_nobgsub);//Fill the deltaR and groomed deltaR "A-Histograms"
		}

		else continue;
		//_________________________________________________________________________________
	}
//End event loop

        cout << "number of matched jets " << n_matched << endl;
	TFile* outFile = new TFile("Output4_Pythia_BG_JetCS_noghost_garea005.root","RECREATE");
   
    	outFile->cd();

    	hJetPt_A->Write();
    	hJetEta_A->Write();
	hJetArea_A->Write();
        hJetMatchFrac->Write();
        hDeltaPt->Write();
	hJet_Rghost_A->Write();
	hJet_Rconst_A->Write();
	hJet_RhoR_A->Write();
	hJet_deltaR_A->Write();
	hJet_deltaRg_A->Write();

    	hJetPt_B->Write();
    	hJetEta_B->Write();
	hJetArea_B->Write();
	hJet_Rconst_B->Write();
	hJet_RhoR_B->Write();
	hJet_deltaR_B->Write();
	hJet_deltaRg_B->Write();

	h_pT->Write();
	h_eta->Write();
	h_phi->Write();

	hP_pT->Write();
	hP_eta->Write();
	hP_phi->Write();

	hT_pT->Write();
	hT_eta->Write();
	hT_phi->Write();
	
    	outFile->Close();

	return 0;
}
